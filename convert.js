// Generated by CoffeeScript 1.3.1
var add_inputs, available_chars, blank, cancel, choose_version, control, ctrl_copy, ctrl_cut, ctrl_paste, current_version, cursor, down, draw, editor_mode, end, enter, esc, home, input, keymap, left, left_step, ll, pair_num, remove, render_cursor, reverse, right, right_step, save_version, snippet, space, store, tag, up, version_cursor, version_map, view_version,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

tag = function(id) {
  return document.getElementById(id);
};

ll = function() {
  var item, time, v, _i, _len, _results;
  v = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  _results = [];
  for (_i = 0, _len = v.length; _i < _len; _i++) {
    item = v[_i];
    time = new Date().getTime();
    _results.push(console.log(time, item));
  }
  return _results;
};

keymap = '';

available_chars = 'abcdefghijjklmnopqrstuvwxyz';

available_chars += 'ABCDEFGHIJJKLMNOPQRSTUVWXYZ';

available_chars += '1234567890!@#$%^&*()';

available_chars += '~`_-+=-[]{}\\|:;"\',.<>/?';

add_inputs = available_chars.split('');

cursor = '\t';

render_cursor = '<nav>&nbsp;</nav>';

draw = function(arr) {
  var inline_block, item, str, _i, _len;
  str = '';
  for (_i = 0, _len = arr.length; _i < _len; _i++) {
    item = arr[_i];
    if (Array.isArray(item)) {
      str += draw(item);
    } else if (item === cursor) {
      str += render_cursor;
    } else {
      item = item.replace(cursor, render_cursor).replace(/\s/g, '<span class="appear">&nbsp;</span>');
      str += "<code>" + item + "</code>";
    }
  }
  inline_block = '';
  if (arr.toString().length < 15) {
    inline_block = ' class="inline_block"';
  }
  return "<div" + inline_block + ">" + str + "</div>";
};

editor_mode = true;

window.onload = function() {
  var box, refresh;
  box = tag('box');
  window.focus();
  (refresh = function() {
    box.innerHTML = draw(store);
    return console.log('Refreshing :::: ', store);
  })();
  document.onkeypress = function(e) {
    var char;
    char = String.fromCharCode(e.keyCode);
    if (!(e.ctrlKey || e.altKey)) {
      if (__indexOf.call(add_inputs, char) >= 0) {
        input(char);
        refresh();
      }
      return false;
    }
  };
  return document.onkeydown = function(e) {
    var code, send_back;
    if (editor_mode === false) {
      editor_mode = true;
      refresh();
      return false;
    }
    code = e.keyCode;
    console.log('keyCode .... ', code, e.ctrlKey);
    if (!(e.ctrlKey || e.altKey)) {
      if (control['' + code] != null) {
        control['' + code]();
        refresh();
        return false;
      }
    }
    if (e.ctrlKey && (!e.altKey)) {
      if (control['c_' + code] != null) {
        send_back = control['c_' + code]();
        if (send_back !== 'no need to refresh') {
          refresh();
        }
        return false;
      }
    }
  };
};

store = ['45345', '345345', ['44', '5', 'sdfsdfsdf\t', ['444']]];

input = function(char) {
  var recursion;
  recursion = function(arr) {
    var c, coll, copy, item, _i, _j, _len, _len1;
    copy = [];
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      item = arr[_i];
      if (Array.isArray(item)) {
        copy.push(recursion(item));
      } else if (item === cursor) {
        copy.push("" + char + cursor);
      } else {
        coll = '';
        for (_j = 0, _len1 = item.length; _j < _len1; _j++) {
          c = item[_j];
          if (c === cursor) {
            coll += char;
          }
          coll += c;
        }
        copy.push(coll);
      }
    }
    return copy;
  };
  return store = recursion(store);
};

cancel = function() {
  var recursion;
  if (store[0] === cursor) {
    return 'nothing to do';
  }
  recursion = function(arr) {
    var c, coll, copy, cursor_place, item, _i, _j, _len, _len1;
    if (__indexOf.call(arr, cursor) >= 0) {
      if (arr[0] === cursor) {
        return arr;
      }
      cursor_place = arr.indexOf(cursor);
      arr = arr.slice(0, cursor_place - 1).concat(arr.slice(cursor_place));
      return arr;
    }
    copy = [];
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      item = arr[_i];
      if (Array.isArray(item)) {
        copy.push(recursion(item));
      } else {
        if (item[0] === cursor) {
          return cursor;
        }
        coll = '';
        for (_j = 0, _len1 = item.length; _j < _len1; _j++) {
          c = item[_j];
          if (c === cursor) {
            coll = coll.slice(0, -1);
          }
          coll += c;
        }
        copy.push(coll);
      }
    }
    return copy;
  };
  return store = recursion(store);
};

space = function() {
  var recursion;
  recursion = function(arr) {
    var copy, cursor_place, item, _i, _len;
    copy = [];
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      item = arr[_i];
      if (Array.isArray(item)) {
        copy.push(recursion(item));
      } else {
        cursor_place = item.indexOf(cursor);
        if (cursor_place === -1) {
          copy.push(item);
        } else {
          copy.push(item.replace(cursor, ''));
          copy.push(cursor);
        }
      }
    }
    return copy;
  };
  return store = recursion(store);
};

enter = function() {
  var recursion;
  recursion = function(arr) {
    var copy, cursor_place, item, _i, _len;
    if (__indexOf.call(arr, cursor) >= 0) {
      return arr.map(function(x) {
        if (x === cursor) {
          return [x];
        } else {
          return x;
        }
      });
    }
    copy = [];
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      item = arr[_i];
      if (Array.isArray(item)) {
        copy.push(recursion(item));
      } else {
        cursor_place = item.indexOf(cursor);
        if (cursor_place === -1) {
          copy.push(item);
        } else {
          copy.push(item.replace(cursor, ''));
          copy.push([cursor]);
        }
      }
    }
    return copy;
  };
  return store = recursion(store);
};

blank = function() {
  return input(' ');
};

esc = function() {
  var recursion;
  if (__indexOf.call(store, cursor) >= 0) {
    return 'top level.. dont do enything';
  }
  recursion = function(arr) {
    var copy, cursor_place, item, last_item, _i, _len;
    copy = [];
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      item = arr[_i];
      if (Array.isArray(item)) {
        if (__indexOf.call(item, cursor) >= 0) {
          last_item = item.filter(function(x) {
            return x !== cursor;
          });
          if (last_item.length > 0) {
            copy.push(last_item);
          }
          copy.push(cursor);
        } else {
          copy.push(recursion(item));
        }
      } else {
        cursor_place = item.indexOf(cursor);
        if (cursor_place === -1) {
          copy.push(item);
        } else {
          copy.push(item.replace(cursor, ''));
          copy.push(cursor);
        }
      }
    }
    return copy;
  };
  return store = recursion(store);
};

home = function() {
  var recursion;
  if ((store[0] != null) && store[0] === cursor) {
    return 'top level, nothing to do';
  }
  recursion = function(arr) {
    var copy, find_cursor, item, _i, _len;
    if (__indexOf.call(arr, cursor) >= 0 && (arr[0] !== cursor)) {
      return [cursor].concat(arr.filter(function(x) {
        return x !== cursor;
      }));
    }
    copy = [];
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      item = arr[_i];
      if (item[0] === cursor) {
        copy.push(cursor);
        if (item.length > 1) {
          copy.push(item.slice(1));
        }
      } else {
        if (Array.isArray(item)) {
          copy.push(recursion(item));
        } else {
          find_cursor = item.match(new RegExp(cursor));
          if (find_cursor != null) {
            copy.push("" + cursor + (item.replace(cursor, '')));
          } else {
            copy.push(item);
          }
        }
      }
    }
    return copy;
  };
  return store = recursion(store);
};

reverse = function(arr) {
  var c, coll, copy, item, _i, _j, _len, _len1, _ref, _ref1;
  copy = [];
  _ref = arr.reverse();
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    item = _ref[_i];
    if (Array.isArray(item)) {
      copy.push(reverse(item));
    } else {
      coll = '';
      _ref1 = item.split('').reverse();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        c = _ref1[_j];
        coll += c;
      }
      copy.push(coll);
    }
  }
  return copy;
};

end = function() {
  store = reverse(store);
  home();
  return store = reverse(store);
};

remove = function() {
  var recursion;
  if (__indexOf.call(store, cursor) >= 0) {
    store = [cursor];
    return 'done';
  }
  recursion = function(arr) {
    return arr.map(function(x) {
      if (Array.isArray(x)) {
        if (__indexOf.call(x, cursor) >= 0) {
          return cursor;
        } else {
          return recursion(x);
        }
      } else {
        if (x.match(new RegExp(cursor)) != null) {
          return cursor;
        } else {
          return x;
        }
      }
    });
  };
  return store = recursion(store);
};

left = function() {
  var recursion;
  if (store[0] === cursor) {
    return 'ok';
  }
  recursion = function(arr) {
    var copy, find_cursor, item, last_item, swapit, _i, _len;
    copy = [];
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      item = arr[_i];
      if (Array.isArray(item)) {
        if (item[0] === cursor) {
          copy.push(cursor);
          if (item.length > 1) {
            copy.push(item.slice(1));
          }
        } else {
          copy.push(recursion(item));
        }
      } else if (item === cursor) {
        last_item = copy.pop();
        if (Array.isArray(last_item)) {
          last_item.push(cursor);
          copy.push(last_item);
        } else {
          copy.push("" + last_item + cursor);
        }
      } else {
        if (item[0] === cursor) {
          copy.push(cursor);
          if (item.length > 1) {
            copy.push(item.slice(1));
          }
        } else {
          find_cursor = item.match(new RegExp(cursor));
          if (find_cursor == null) {
            copy.push(item);
          } else {
            swapit = new RegExp("(.)" + cursor);
            copy.push(item.replace(swapit, "" + cursor + "$1"));
          }
        }
      }
    }
    return copy;
  };
  return store = recursion(store);
};

right = function() {
  store = reverse(store);
  left();
  return store = reverse(store);
};

down = function() {
  var copy_tail, item, recursion, _i, _len;
  copy_tail = store.concat().reverse();
  for (_i = 0, _len = copy_tail.length; _i < _len; _i++) {
    item = copy_tail[_i];
    if (Array.isArray(item)) {
      break;
    }
    if (item === cursor || item === [cursor]) {
      return 'no need';
    }
    if (item.match(new RegExp(cursor)) != null) {
      return 'yeah';
    }
  }
  recursion = function(arr) {
    var copy, has_cursor, item, obj, _j, _len1;
    copy = [];
    has_cursor = false;
    for (_j = 0, _len1 = arr.length; _j < _len1; _j++) {
      item = arr[_j];
      if (item === cursor || item === [cursor]) {
        has_cursor = true;
      } else if (typeof item === 'string') {
        if (item.match(new RegExp(cursor)) != null) {
          copy.push(item.replace(new RegExp(cursor), ''));
          has_cursor = true;
        } else {
          copy.push(item);
        }
      } else {
        if (has_cursor) {
          item.unshift(cursor);
          copy.push(item);
          has_cursor = false;
        } else {
          obj = recursion(item);
          copy.push(obj.value);
          if (obj.has_cursor) {
            copy.push(cursor);
          }
        }
      }
    }
    return obj = {
      value: copy,
      has_cursor: has_cursor
    };
  };
  return store = (recursion(store)).value;
};

up = function() {
  store = reverse(store);
  down();
  return store = reverse(store);
};

left_step = function() {
  var recursion;
  recursion = function(arr) {
    var copy, find_cursor, item, last_item, _i, _len;
    if (arr[0] === cursor) {
      return arr;
    }
    copy = [];
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      item = arr[_i];
      if (Array.isArray(item)) {
        copy.push(recursion(item));
      } else if (item === cursor) {
        last_item = copy.pop();
        copy.push(cursor, last_item);
      } else {
        find_cursor = item.match(new RegExp(cursor));
        if (find_cursor == null) {
          copy.push(item);
        } else {
          copy.push(cursor, item.replace(cursor, ''));
        }
      }
    }
    return copy;
  };
  return store = recursion(store);
};

right_step = function() {
  store = reverse(store);
  left_step();
  return store = reverse(store);
};

snippet = null;

ctrl_copy = function() {
  var recursion;
  recursion = function(arr) {
    var item, _i, _len;
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      item = arr[_i];
      if (Array.isArray(item)) {
        if (__indexOf.call(item, cursor) >= 0) {
          snippet = item.filter(function(x) {
            return x !== cursor;
          });
          return 'got';
        }
        recursion(item);
      } else {
        if (item.indexOf(cursor) >= 0) {
          snippet = item.replace(cursor, '');
          return 'got';
        }
      }
    }
  };
  return recursion(store);
};

ctrl_cut = function() {
  var recursion;
  if (__indexOf.call(store, cursor) >= 0) {
    return 'wont do';
  }
  recursion = function(arr) {
    var copy, item, _i, _len;
    copy = [];
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      item = arr[_i];
      if (Array.isArray(item)) {
        if (__indexOf.call(item, cursor) >= 0) {
          copy.push(cursor);
          snippet = item.filter(function(x) {
            return x !== cursor;
          });
        } else {
          copy.push(recursion(item));
        }
      } else {
        if (item.indexOf(cursor) >= 0) {
          copy.push(cursor);
          snippet = item.replace(cursor, '');
        } else {
          copy.push(item);
        }
      }
    }
    return copy;
  };
  return store = recursion(store);
};

ctrl_paste = function() {
  var recursion;
  recursion = function(arr) {
    var copy, item, _i, _len;
    copy = [];
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      item = arr[_i];
      if (Array.isArray(item)) {
        copy.push(recursion(item));
      } else if (item === cursor) {
        copy.push(snippet, cursor);
      } else if (item.indexOf(cursor) < 0) {
        copy.push(item);
      } else {
        copy.push(snippet, item);
      }
    }
    return copy;
  };
  if (snippet != null) {
    return store = recursion(store);
  }
};

version_map = {
  store: ['console', 'log', 'hello world'],
  stemp: 'no time',
  child: [cursor],
  commit: 'root'
};

version_cursor = version_map.child;

pair_num = function(num) {
  if (num < 10) {
    return String(num);
  } else {
    return '0' + (String(num));
  }
};

save_version = function() {
  var date, date_obj, hour, last_item, minute, month, stemp, year;
  date_obj = new Date();
  year = (String(date_obj.getFullYear())).slice(2, 4);
  month = pair_num(date_obj.getMonth() + 1);
  date = pair_num(date_obj.getDate());
  hour = pair_num(date_obj.getHours());
  minute = pair_num(date_obj.getMinutes());
  stemp = "" + year + "/" + month + "/" + date + " " + hour + ":" + minute;
  version_cursor.pop();
  version_cursor.push({
    store: store,
    stemp: stemp,
    child: [],
    commit: prompt()
  });
  last_item = version_cursor;
  version_cursor = version_cursor[last_item.length - 1].child;
  version_cursor.push(cursor);
  console.log('version :: ', version_map);
  return 'no need to refresh';
};

choose_version = function(new_version_cursor) {
  save_version();
  version_cursor.pop();
  version_cursor = new_version_cursor;
  return version_cursor.push(cursor);
};

current_version = 'current_version';

view_version = function() {
  var recursion;
  recursion = function(obj) {
    var str;
    if (obj === cursor) {
      return current_version;
    }
    console.log('obj:: ', obj);
    if (obj.commit != null) {
      str = "commit: " + obj.commit + "<br>";
      str += "time: " + obj.stemp + "<br>";
      str += obj.child.map(recursion).join('');
    }
    if (str != null) {
      return "<footer>" + str + "</footer>";
    } else {
      return '';
    }
  };
  tag('box').innerHTML = recursion(version_map);
  editor_mode = false;
  return 'no need to refresh';
};

control = {
  '8': cancel,
  '13': enter,
  '32': space,
  '9': blank,
  '27': esc,
  '37': left,
  '39': right,
  '38': up,
  '40': down,
  '36': home,
  '35': end,
  '46': remove,
  'c_37': left_step,
  'c_39': right_step,
  'c_67': ctrl_copy,
  'c_88': ctrl_cut,
  'c_80': ctrl_paste,
  'c_83': save_version,
  'c_86': view_version
};
